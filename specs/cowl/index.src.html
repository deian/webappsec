<h1>Confinement with Origin Web Labels</h1>
<pre class="metadata">
Status: ED
Group: WebAppSec
ED: https://w3c.github.io/webappsec/specs/cowl/
Shortname: COWL
Level: 1
Editor: Deian Stefan, Stanford University, deian@cs.stanford.edu
Abstract:
  This specification defines an API for specifying privacy and
  integrity policies on data, in the form of origin labels, and a
  mechanism for confining code according to such policies.  This
  allows Web application authors and server operators to shared data
  with untrusted&mdash;buggy but not malicious&mdash;code (e.g., in a mashup
  scenario) yet impose restrictions on how the code can share the data
  further.

  In addition, this specification defines a light-weight, in-thread
  Worker.  Combined with confinement, this allows developers to build
  privilege-separated, compartmentalized applications.
Indent: 2
</pre>
<pre class="anchors">
spec: CORS; urlPrefix: http://www.w3.org/TR/cors/
  type: dfn
    text: CORS
spec: WEBMESSAGING; urlPrefix: http://www.w3.org/TR/webmessaging/
  type: method
    text: postMessage(); url: dom-window-postmessage
spec: WORKERS; urlPrefix: http://www.w3.org/TR/workers/
  type: interface
    text: Worker
spec: CSP2; urlPrefix: https://www.w3.org/TR/CSP2/
  type: dfn
    text: content-security-policy
spec: HTML5; urlPrefix: http://www.w3.org/TR/html5/
  type: element-attr
    urlPrefix: embedded-content-0.html
      text: sandbox; for: iframe; url: attr-iframe-sandbox
  type: dfn
    urlPrefix: embedded-content-0.html
      text: iframe; url: the-iframe-element
    urlPrefix: browsers.html
      text: context; url: windows
      text: browsing context; url: windows
    urlPrefix: infrastructure.html
      text: structured clone; url: structured-clone
      text: structurally cloned; url: structured-clone
      text: structurally clonable; url: structured-clone
spec: RFC6454; urlPrefix: https://tools.ietf.org/html/rfc6454
  type: dfn
    text: origin; url: section-3.2
    text: globally unique identifier; url: section-2.3
spec: URL; urlPrefix: http://www.w3.org/TR/url/
  type: interface
    text: URL; url: concept-url
  type: dfn
    text: scheme; url: concept-url-scheme
  type: attribute
    text: host; for: URL; url: concept-url-host
    text: path; for: URL; url: concept-url-path
    text: port; for: URL; url: concept-url-port
    text: scheme; for: URL; url: concept-url-scheme
spec: RFC7159; urlPrefix: https://tools.ietf.org/html/rfc4627
  type: dfn
    text: JSON object; url: section-2
    text: JSON stringification; url: section-2
</pre>

<!-- BIBLIOGRAPHY -->
<pre class="biblio">
{
  "DCLabels": {
    "authors": ["Deian Stefan", "Alejandro Russo", "David Mazieres", "John C. Mitchell"],
    "title": "Disjunction Category Labels",
    "href": "http://www.scs.stanford.edu/~deian/pubs/stefan:2011:dclabels.pdf",
    "publisher": "Springer Berlin Heidelberg"
  },
  "URL": {
    "authors": [ "Anne van Kesteren", "Sam Ruby" ],
    "title": "URL",
    "href": "http://www.w3.org/TR/url",
    "status": "WD",
    "publisher": "W3C"
  },
  "WEBIDL2": {
    "authors": [ "Cameron McCormack", "Boris Zbarsky" ],
    "title": "Web IDL (Second Edition)",
    "href": "https://heycam.github.io/webidl/",
    "status": "ED",
    "publisher": "W3C"
  }
}
</pre>

<!-- Big Text: intro -->
<section>
  <h2 id="intro">Introduction</h2>

  <em>This section is not normative.</em>

  Modern Web applications are conglomerations of JavaScript written by
  multiple authors. Authors routinely incorporate third-party scripts
  into their applications and share user data with third-party
  services (e.g., as part of a <em>mashup</em>).  Unfortunately, in
  the existing model, authors put the user's data confidentiality and
  integrity at risk when incorporating such untrusted third-party code
  or sharing data with untrusted third-party services.

  Mechanisms such as CORS and CSP can be used to mitigate these risks
  by giving authors control over whom they share data with. But, once
  data is shared, these mechanisms do not impose any restrictions on
  how the code that was "granted access" can further disseminate the
  data.

  This document specifies an extension to the current model called
  Confinement with Origin Web Labels (COWL). COWL provides authors
  with APIs for specifying access control policies on data (including
  content) in terms of <a>origin labels</a>.  These policies are
  enforced in a mandatory fashion, transitively, even once code has
  access to the data.  For example, with COWL, the author of
  <code>https://example.com/</code> can specify that a password is
  confidential to <code>https://example.com/</code> (and thus should
  only be disclosed to <code>https://example.com/</code>) before
  sharing it with a third-party password strength checking service. In
  turn, COWL ensures that the third-party service, which necessarily
  computes on the password, is confined and respects the policy on the
  password, i.e., it cannot disclose the password to any origin other
  than <code>https://example.com/</code>.

  COWL enforces such policies by confining code, at the
  <a>context</a>-level, according to the sensitivity of the data the
  code has observed. To reap the greatest benefits of COWL, authors
  will need to compartmentalize applications into multiple contexts
  (e.g., <a>iframe</a> or <a>light-weight Workers</a>). For example,
  untrusted libraries should be loaded in <a>light-weight Workers</a>
  instead of directly into a page.

  COWL is intended to be used as a defense-in-depth mechanism that can
  restrict how untrusted code handles sensitive data. To prevent
  untrusted code from accessing data in the first place, authors should
  still use discretionary access control mechanisms, such as CSP and
  CORS.


  <section>
  <h3 id="goals">Goals</h3>

  The goal of COWL is to provide authors with a means for protecting
  the confidentiality and integrity of data that is shared with
  untrusted, whether third-party or their own, code.  Existing
  mechanisms (e.g., CORS and the <a>postMessage()</a> <a argument
    for="postMessage()">targetOrigin</a> argument) provide a way for
  restricting which origins may access (shared) data.  But, once
  content has access to data it can usually disseminate it without
  restrictions.  While CSP can be used to confine code, and thus
  restrict how confidential data is disseminated, setting a correct
  CSP policy (as to confine code) is difficult and limited to
  content the author has control over. Indeed, sharing confidential
  data (e.g., via cross-document messaging) implicitly requires the
  author to trust the receiver not to leak the data, accidentally or
  otherwise.  COWL provides a defense-in-depth option for
  protecting data confidentiality and integrity.  In particular,
  with COWL:

  1. Authors should be able to specify confidentiality and integrity
  policies on data in terms of origin labels: the origins to whom the
  data is confidential and the origins that endorse the data.  This
  allows authors to share sensitive data with third-party content and
  impose restrictions on the origins with which it can communicate
  once it inspects the sensitive data. Dually, it allows authors to
  share data via intermediate content while retaining its integrity.

  2. Authors should be able to run code with <em>least privilege</em>
  by restricting how the code can disseminate sensitive data.

  3. Authors should be able to <em>privilege separate</em>
  applications by loading untrusted scripts in separate
  <a>light-weight Workers</a> instead of inline <{script}> elements,
  which have the same privileges as content.

  </section>

  <section>
  <h3 id="examples">Use Cases/Examples</h3>
  <h4 id="examples-checker">Untrusted service</h4>

  An author wishes to use a service (e.g., in the form of an iframe)
  without trusting it (or its dependencies) to not leak their
  sensitive data. To protect the data, the author associates a
  <a>label</a> with the data, which encodes a security policy
  specifying the origins allowed to read the data, and shares the
  newly created <a>labeled object</a> with the untrusted code. In
  turn, COWL confines the untrusted code, once it inspects the
  sensitive data, such that it can only communicate according to the
  author-specified policy.

  <div id="example-checker" class="example">
    Consider using a third-party password strength checker provided by
    <code>https://untrusted.com</code>, loaded in the form of an
    iframe. To protect the confidentiality of the password, the
    <code>https://example.com</code> application can use COWL to
    associate a confidentiality policy, in the form of a <a>label</a>,
    with the password before sending it to the untrusted service:

    <pre><code>
    // Create new policy as a <a interface>Label</a> specifying that the password is sensitive
    // to https://example.com and should only be disclosed to this origin:
    var policy = new <a interface>Label</a>(window.location.origin);

    // Associate the label with the password:
    var labeldPassword = new <a interface>LabeledObject</a>(password, {confidentiality: policy});

    // Send the labeled password to the checker iframe:
    checker.postMessage(labeledPassword, "https://untrusted.com");

    // Register listener to receive response from checker, ...
    </code></pre>

    Once the checker inspects the password, COWL limits the iframe to
    communicating with origins that preserve the password's
    confidentiality, i.e., <code>https://example.com</code>. Indeed,
    this policy is enforced mandatory, even if the
    <code>https://untrusted.com</code> service sends the password to
    yet another party.

    Note, until the checker actually inspects the protected password,
    it can communicate freely, e.g., with <code>https://untrusted.com</code>.
    This is important since the checker may need to fetch resources
    (e.g., regular expressions) to check the password strength; it is
    also safe, since it has not inspected the sensitive password.
  </div>

  <h4 id="examples-checker-worker">Untrusted library</h4>

  ISSUE: describe use of workers

  <h4 id="examples-mashup">Third-party mashup</h4>

  ISSUE: describe client-side mint or encrypted document editor.

  <h4 id="examples-leastpriv">Least-privileged content</h4>

  ISSUE: describe how to drop privileges.

  <h4 id="examples-privsep">Privilege separation</h4>

  ISSUE: describe how page can be divided into components with
  different privileges.

  <h4 id="examples-isolation">User isolation</h4>

  ISSUE: describe how to privileges can be delegated and used to
  isolate different users of a web site.

  </section>
  <section>
    <h3 id="trust-model">Trust Model</h3>
    COWL provides developers with a way of imposing restrictions on
    how untrusted code can disseminate sensitive data.  However,
    authors should not share sensitive data with malicious code, since
    such code may be able to exploit covert channels, which are present
    in most browsers, to leak the data.  COWL can only prevent
    information leakage from code that (e.g., is buggy and) uses
    overt communication channels.

    Note, COWL should be used as an additional defense layer to other
    security mechanisms such as CSP, SRI, CORS, and iframe <code><a
    element-attr>sandbox</a></code>.
  </section>
</section>

<!-- Big Text: definitions -->
<section>
  <h2 id="key-concepts">Key Concepts and Terminology</h2>
  <h3>Labels</h3>
  <ol>
    <li>
      An <dfn>origin label</dfn>, or more succinctly a
      <dfn>label</dfn>, encodes either a confidentiality or integrity
      security policy. Labels are associated with <a>contexts</a>;
      they can also be associated with <a>structurally clonable</a>
      objects.

      When associated with a <a>context</a>, the label restricts the
      origins that the context can communicate with, as detailed in
      [[#context-labels]].

      <div class="example">
       When associate with a context, the confidentiality label
       <code>
          <a interface>Label</a>("https://a.com").<a>or</a>("https://b.com")
       </code>
       restricts the context to sending data to
       <code>https://a.com</code> or <code>https://b.com</code>, but
       no other origins.
       The context label reflects the fact the context may contain data
       that is sensitive to either <code>https://a.com</code> or
       <code>https://b.com</code>; it is thus only safe for it to
       communicate <em>to</em> these origins.

       Note, because the context can communicate data to either origin,
       another context associated with the more-strict
       <code><a interface>Label</a>("https://a.com")</code> label cannot
       send it data. Doing so may allow for data confidential
       to <code>https://a.com</code> to be leaked to <code>https://b.com</code>.
      </div>

      When associated with an object, a confidentiality label
      specifies the origins to whom the object is sensitive, while an
      integrity label specifies the origins that endorse the object.
      [[#object-labels]] defines how labels are associated with
      objects. Objects that have labels associated with them are
      called <dfn>labeled objects</dfn>.

      <div class="example">
        Consider an <code>https://example.com</code> application that
        receives a labeled object (e.g., via <a>postMessage()</a>)
        with the following labels:

        * Confidentiality label: 
        <code><a interface>Label</a>("https://example.com")</code>.
        This label indicates that the object is confidential to
        <code>https://example.com</code>.

        * Integrity label: 
        <code><a interface>Label</a>("https://a.com")</code>.
        This label indicates that the object has been endorsed by
        <code>https://a.com</code>. If
        <code>https://example.com</code> received the message from
        <code>https://b.com</code>, the label reflects the fact that the
        object was not tampered by <code>https://b.com</code>.
      </div>
    </li>
    <li>
      A label is in <dfn>normal form</dfn> if reducing it according to
      the <a>label normal form reduction</a> algorithm produces the
      same value. Mathematically, a label in <a>normal form</a>
      corresponds to a set of origins in <a>conjunction normal
        form</a> [[DCLabels]].
    </li>
    <li>
      Two labels are <dfn>equivalent</dfn> if their <a>normal form</a>
      values are equal.
    </li>
    <li>
      A label <var>A</var> <dfn>subsumes</dfn> another label
      <var>B</var> if the result of running the <a>label subsumption</a>
      algorithm on the <a>normal form</a>s of <var>A</var> and
      <var>B</var> returns <code>true</code>.
    </li>
    <li>
      When reading a <a>labeled objects</a> a context gets
      <dfn>tainted</dfn> (through invocations of the <a>context
      tainting</a> algorithm) to reflect that it has read sensitive
      data and should be confined accordingly.
    </li>
    <li>
      The <dfn>current confidentiality label</dfn> is the
      confidentiality label associated with the current context.
      [[#context-labels]] specifies how labels are associated with
      contexts.
    </li>
    <li>
      The <dfn>current integrity label</dfn> is the
      integrity label associated with the current context.
      [[#context-labels]] specifies how labels are associated with
      contexts.
    </li>
  </ol>
  <h3>Privileges</h3>
  <ol>
    <li>
      A <dfn>privilege</dfn> is an unforgeable object that corresponds
      to a <a>label</a>. Privileges are associated with contexts.

      Privileges can be used to bypass confinement restrictions
      imposed by confidentiality labels.  In particular, a privilege
      can be used to bypass the restrictions imposed by any label that
      its underlying label&mdash;the <a>internal privilege
      label</a>&mdash;subsumes.

      <div class="example">
        Consider an <code>https://a.com</code> contexts whose
        <a>current confidentiality label</a> is <code><a
            interface>Label</a>("https://a.com").and("https://b.com")</code>.
        This label confines the context to only communicating with
        entities whose labels are at least as restricting as this
        label. For example, it restricts the context from
        communicating with a context labeled <code><a
           interface>Label</a>("https://b.com")</code> context, since doing
        so would potentially leak <code>https://a.com</code> data to 
        <code>https://b.com</code>. It similarly cannot communicate with
        <code>https://a.com</code>.
        
        However, if the context's <a>current privilege</a> corresponds
        to <code><a interface>Label</a>("https://a.com")</code>, then it
        would be able to bypass the restriction imposed by this label.
        In particular, the context would be able to communicate with
        <code>https://b.com</code>&mdash;the privilege confers the right
        to declassify <code>https://a.com</code> data to
        <code>https://b.com</code>&mdash;since the <a>effective
        confidentiality label</a> is
        <code><a interface>Label</a>("https://b.com")</code>.
        
        Note, the context is responsible for ensuring that
        <code>http://a.com</code> data is not accidentally leaked.
        Hence, when using cross-document messaging authors should
        always use <a interface>LabeledObject</a>s.
        
        Note, the privilege cannot bypass any label restrictions. For
        example, it does not allow the context to communicate with
        <code>https://a.com</code> since doing so would potentially leak
        <code>https://b.com</code> data.
      </div>

      Privileges can also be used to bypass integrity restrictions
      imposed by integrity labels. In particular, a privilege can be
      used to endorse an otherwise untrustworthy <a>labeled
      context</a> (or <a>labeled object</a>) thereby allowing it to
      communicate with more trustworthy end-points (another context or
      server).

      <div class="example">
        Consider an <code>https://a.com</code> contexts whose
        <a>current integrity label</a> is
        <code><a interface>Label</a>("https://a.com").or("https://b.com")</code>.
        This label confines the context to only communicating with
        entities that are at most as trustworthy as this
        label. For example, it restricts the context from
        communicating with a context whose <a>current integrity
        label</a> is
        <code><a interface>Label</a>("https://a.com")</code>, since doing
        so would potentially corrupt
        <code>https://a.com</code> data&mdash;the computation was
        potentially influence by <code>https://b.com</code>.

        However, if the context's <a>current privilege</a> corresponds
        to <code><a interface>Label</a>("https://a.com")</code>, then it
        would be able to bypass the restriction imposed by this label.
        In particular, the context would be able to communicate with
        the other context since the privilege confers it the right
        to speak on behalf of <code>https://a.com</code>. Indeed, its
        <a>effective integrity label</a> is <code><a
        interface>Label</a>("https://b.com")</code>. 
  
        Note, the receiving context is responsible for ensuring
        that <code>http://b.com</code> data did not influence the
        sender's behaviour in an inadvertent way.  Hence, when using
        cross-document messaging authors should always demand the use
        <a interface>LabeledObject</a>s.
        
        Note, the privilege cannot bypass any label restrictions. For
        example, it does not allow the context to communicate with
        a context whose integrity label is
        <code><a interface>Label</a>(https://b.com</code>.
      </div>

      Note, <a>browsing contexts</a> have a <a>current privilege</a>
      that, by default, corresponds to the origin of the context, as
      described in [[#context-labels]]. Authors can set the <a>current
      privilege</a> of a context to ensure that it runs with <em>least
      privilege</em>.

    </li>
    <li>
      The <dfn>current privilege</dfn> is the privilege associated
      with the current context. [[#context-labels]] specifies how
      privileges are associated with contexts.
    </li>
    <li>
      The <dfn>effective confidentiality label</dfn> is the label
      returned by the <a>label downgrade</a> algorithm when invoked
      with the <a>current confidentiality label</a> and <a>current
      privilege</a>.
    </li>
    <li>
      The <dfn>effective integrity label</dfn> is the label
      returned by the <a>label downgrade</a> algorithm when invoked
      with the <a>current integrity label</a> and <a>current
      privilege</a>.
    </li>
    <li>
      Code can take <dfn>ownership</dfn> of a <a>privilege</a>
      <var>priv</var> by
      setting the <a>current privilege</a> to the privilege produced
      by <a>combining</a> the <a>current privilege</a> and
      <var>priv</var>.
    </li>
  </ol>
</section>

<!-- Big Text: framework -->
<section>
  <h2 id="framework">Framework</h2>

  <section>
    <h3 id="label">Label interface</h3>

    Each <a>label</a> is represented by a <a interface>Label</a>
    object, the interface of which is defined in this section.

    A <a interface>Label</a> MUST have an internal <dfn>label set</dfn>, which is
    a non-empty set of <a>disjunction set</a>s.

    A <dfn>disjunction set</dfn> is a set of <a>origin</a>
    <a>URL</a>s.

    A label is said to be an <dfn>empty label</dfn> if its <a>label
      set</a> contains a single, empty <a>disjunction set</a>.

    <pre class="idl">
      [Constructor, Constructor(DOMString origin)]
      interface Label {
        boolean equals(Label other);
        boolean subsumes(Label other);

        Label and((Label or DOMString) other);
        Label _or((Label or DOMString) other);

        object toJSON();
        [Throws] static Label fromJSON(object obj);
      };
    </pre>

    ISSUE: Current WebIDL implementation requires an underscore for
    certain identifiers. Can we rename <code>_or</code> to
    <code>or</code>?

    <h4>Constructors</h4>
    <dl dfn-for="Label">
      <dt><dfn constructor>Label()</dfn></dt>
      <dd>
        When invoking the <a>Label()</a> constructor, the user agent
        MUST return a new <a>empty label</a>.
      </dd>
      <dt><dfn constructor>Label(DOMString origin)</dfn></dt>
      <dd>
        When invoking the <a>Label(origin)</a> constructor, the user agent
        MUST use an algorithm equivalent to the following:

        1.  If the <a argument for="Label/Label(origin)">origin</a>
        argument is not a <a>URL</a>, the constructor MUST throw a
        <code>TypeError</code> exception [[!ECMA-262]] and
        terminate this algorithm.

        2. Else, it MUST return a new <a>Label</a> that contains a
        <a>label set</a> of a single <a>disjunction set</a>, which
        itself MUST contain the <a>URL</a> corresponding to the
        <a>origin</a> of the parameter.
      </dd>
    </dl>

    <h4>Methods</h4>
    <dl dfn-for="Label">
      <dt><dfn method title="equals(other)">equals(Label other)</dfn></dt>
      <dd>
        MUST return <code>true</code> if the <a interface>Label</a> on
        which the method has been called is <a>equivalent</a> to the
        <a argument for="Label/equals(other)">other</a>
        parameter; otherwise it MUST return <code>false</code>
      </dd>
      <dt><dfn method title="subsumes(other)">subsumes(Label other)</dfn></dt>
      <dd>
        MUST return <code>true</code> if the <a interface>Label</a> on
        which the method has been called <a>subsumes</a> the
        <a argument for="Label/subsumes(other)">other</a>
        parameter; otherwise it MUST return <code>false</code>
      </dd>
      <dt><dfn method title="and(other)">and((Label or DOMString) other)</dfn></dt>
      <dd>
        The user agent MUST use an algorithm equivalent to the following:

        1. Let <var>O</var> be the
        <a argument for="Label/and(other)">other</a> argument.

        1.  If the type of <a argument for="Label/and(other)">other</a> is
        <a>DOMString</a>, run the following sub-steps:

          1. Set <var>O</var> to the result of invoking the
          <a>Label()</a> constructor with <a argument
          for="Label/and(other)">other</a> as an argument, if the
          constructor did not raise an exception.

          2. Else, re-throw the exception and terminate this algorithm.

        2. Return a new <a interface>Label</a>, in <a>normal form</a>, which is
        <a>equivalent</a> to adding <var>O</var>'s <a>label set</a> to
        the <a>label set</a> of the <a interface>Label</a> on which
        the method was invoked.
      </dd>
      <dt><dfn method title="_or(other)">_or((Label or DOMString) other)</dfn></dt>
      <dd>
        The user agent MUST use an algorithm equivalent to the following:

        1. Let <var>O</var> be the
        <a argument for="Label/and(other)">other</a> argument.

        1.  If the type of <a argument for="Label/_or(other)">other</a> is
        <a>DOMString</a>, run the following sub-steps:

          1. Set <var>O</var> to the result of invoking the
          <a>Label()</a> constructor with <a argument
          for="Label/_or(other)">other</a> as an argument, if the
          constructor did not raise an exception.

          2. Else, re-throw the exception and terminate this algorithm.

        2. Return a new <a interface>Label</a>, in <a>normal form</a>,
        which is <a>equivalent</a> to adding each element of each
        <a>disjunction set</a> of <var>O</var>'s <a>label set</a> to
        each <a>disjunction set</a> of the <a>label set</a> of the
        <a interface>Label</a> on which the method was called.
      </dd>
    </dl>

    ISSUE: describe the <a>toJSON()</a> and <a>fromJSON()</a>

    <div class="example">
      Example labels. Intuition for each label's semantics is given in
      the context of it being used as a confidentiality label (C) and
      integrity label (I).
      <pre><code>
      // Create an empty label.
      // C: This corresponds to public data.
      // I: This corresponds to non-endorsed/untrustworthy data.
      var empty = new <a interface>Label</a>();

      // C: Data confidential to a.com.
      // I: Data endorsed/trusted by a.com.
      var a = new <a interface>Label</a>("https://a.com");

      // C: Data confidential to b.com.
      // I: Data endorsed/trusted by b.com.
      var a = new <a interface>Label</a>("https://b.com");

      // C: Data confidential to both a.com and b.com
      // I: Data endorsed/trusted by a.com and b.com.
      var aANDb = new <a interface>Label</a>("https://a.com").and("https://b.com");

      // C: Data confidential to either a.com or b.com.
      // I: Data endorsed/trusted by either a.com or b.com.
      var aORb = new <a interface>Label</a>("https://a.com").or("https://b.com");
      </code></pre>
      Examples of label comparisons with intuition for the semantics.
      <pre><code>
      // C: a.com data is more sensitive than public data.
      // I: data endorsed by a.com is more trustworthy than non-endorsed/untrustworthy data.
      a.subsumes(empty) === true;
      b.subsumes(empty) === true;

      // C: Data that is confidential to a.com and b.com is more
      // confidential than data that is only sensitive to a.com.
      //
      // I: Data that is endorsed/trusted by both a.com and b.com is
      // more trustworthy than data endorsed only by a.com
      aANDb.subsumes(a) === true;
      aANDb.subsumes(b) === true;

      // C: Data that that is confidential to a.com is not comparable to
      // data that is confidential to b.com
      //
      // I: Data that that is endorsed by a.com is not comparable to
      // data that is endorsed to b.com
      a.subsumes(b) === false;
      b.subsumes(a) === false;

      // C: Data that is confidential to a.com is more confidential than data that is confidential
      // to either a.com or b.com. Alternative intuition: data that can be read by a.com or b.com
      // can necessarily be read by an entity that can read a.com data alone.
      //
      // I: Data that is endorsed by a.com is more trustworthy than data that is endorsed/trusted
      // by either a.com or b.com. Alternative intuition: an entity that trusts data that is
      // endorsed by either a.com or b.com necessarily trusts data endorsed by a.com alone.
      a.subsumes(aOrb) === true;
      b.subsumes(aOrb) === true;
      </code></pre>
    </div>
  </section>

  <section>
    <h3 id="privileges">Privilege Interface</h3>

    Each <a>privilege</a> is represented by a <a
    interface>Privilege</a> object, the interface of which is
    defined in this section.

    A <a interface>Privilege</a> MUST have an <dfn>internal privilege
    label</dfn>.

    The <dfn>combination</dfn> of privileges <var>A</var> and
    <var>B</var> is a privilege produced by invoking the
    <a>combine()</a> method on <var>A</var> (respectively,
    <var>B</var>) with <var>B</var> (respectively, <var>A</var>) as an
    argument.

    <pre class="idl">
      [Constructor, NamedConstructor=FreshPrivilege]
      interface Privilege {
        Label asLabel();

        Privilege combine(Privilege other);
        [Throws] Privilege delegate(Label label);
      };
    </pre>
    <h4>Constructors</h4>
    <dl dfn-for="Privilege">
      <dt><dfn constructor>Privilege()</dfn></dt>
      <dd>
      When invoking the <a>Privilege()</a> constructor, the user
      agent MUST return a new <a interface>Privilege</a> that has an
      <a>internal privilege label</a> set to
      <code><a>Label()</a></code>.
      </dd>
      <dt><dfn constructor>FreshPrivilege()</dfn></dt>
      <dd>
      When invoking the <a>FreshPrivilege()</a> constructor, the user
      agent MUST use an algorithm equivalent to the following:

      1. Let <var>unique Label</var> be the label produced by invoking the
      <a>Label(other)</a> constructor with a <a>globally unique
        identifier</a>.

      2. Return a new <a interface>Privilege</a> that has an
      <a>internal privilege label</a> set to <var>unique Label</var>.
      </dd>
    </dl>

    <h4>Methods</h4>
    <dl dfn-for="equals">
      <dt><dfn method title="asLabel()">asLabel()</dfn></dt>
      <dd>
      MUST return the <a>internal privilege label</a> of the
      <a interface>Privilege</a> on which the method has been called.
      </dd>
      <dt><dfn method title="combine(other)">combine(Privilege other)</dfn></dt>
      <dd>
      MUST return a new <a interface>Privilege</a> whose <a>internal
      privilege label</a> is <a>equivalent</a> to a <a>label</a>
      created according to an algorithm equivalent to the following:
      
      1. Let <var>lintrnal</var> be the
      <a>internal privilege label</a> of the 
      <a interface>Privilege</a> on which the method has been called.

      2. Let <var>lother</var> be the <a>internal privilege label</a> of
      the <a argument for="Privilege/combine(other)">other</a> argument.

      3. Return <code><var>linternal</var>.<a method for="Label/and(other)">and</a>(<var>lother</var>)</code>.
      </dd>
      <dt><dfn method title="delegate(label)">delegate(Label label)</dfn></dt>
      <dd>
      MUST return a new <a interface>Privilege</a> whose <a>internal
      privilege label</a> is <a>equivalent</a> to a <a>label</a>
      created according to an algorithm equivalent to the following:
      
        1. Let <var>linternal</var> be the
        <a>internal privilege label</a> of the 
        <a interface>Privilege</a> on which the method has been called.

        2. Let <var>lother</var> be the <a>internal privilege label</a> of
        the <a argument for="Privilege/combine(other)">other</a> argument.

        3. Return <code><var>linternal</var>.<a method for="Label/and(other)">and</a>(<var>lother</var>)</code>.
      </dd>
    </dl>

    <div class="note">
      Note, the <a interface>Privilege</a> constructors and
      <a>delegate()</a> provide a way creating privileges.  Context
      code must still take <a>ownership</a> of a privilege or set the
      <a>current privilege</a> to it, for the privilege to be used (to
      bypass label restrictions).
    </div>

    <div class="example">
      To be backwards-compatible with the Same-Origin Policy, COWL
      grants each <a>browsing context</a> a <a>default privilege</a>
      that corresponds to their origin. For example, a page on
      <code>https://example.com</code> has a privilege whose <a>internal
      privilege label</a> is
      <code><a interface>Label</a>("https://example.com")</code>.

      As a result, reading data that is sensitive to
      <code><a interface>Label</a>("https://example.com")</code> does
      not confine the context. For example, reading a
      <a interface>LabeledObject</a> whose confidentiality label is
      <code><a interface>Label</a>("https://example.com")</code> does
      not restrict the context from communicating&mdash;and thus
      accidentally leak that object's contents&mdash;to another origin.
      To prevent such bugs, the author can drop the privilege by
      setting the <a>current privilege</a> to an <a>empty
      privilege</a>:
      <pre><code>
        // Save privilege in case we need it later:
        var __savedPriv = COWL.privilege;

        // Drop privilege:
        COWL.privilege = new <a>Privilege</a>();
      </code></pre>

      After this point, if the context reads data with a
      <code><a interface>Label</a>("https://example.com")</code>
      confidentiality label, COWL will limit it ability to communicate
      with <code>https://example.com")</code>.
    </div>

    <div class="example">
      Consider a modification to <a href="#example-checker">
        password-checker example</a> that uses <a>FreshPrivilege()</a>s
      to ensure that the untrusted checker cannot communicate with any
      entity other than the parent context.
      <pre><code>
        // Create new fresh privilege: 
        var priv = new <a>FreshPrivilege()</a>;

        // Take <a>ownership</a> of the fresh privilege:
        COWL.privilege = COWL.privilege.combine(priv);

        // Associate the unique label with the password:
        var labeldPassword = new <a interface>LabeledObject</a>(password, {confidentiality: priv.asLabel()});

        // Send the labeled password to the checker iframe:
        checker.postMessage(labeledPassword, "https://untrusted.com");
      </code></pre>
      Once the <code>https://untrusted.com</code> context reads the
      password is will be <a>tainted</a> by the unique, <a>internal
      privilege label</a> of <code>priv</code>; the unique origin
      ensures that it cannot send the password to, for example, public
      parts of <code>https://example.com</code>. Indeed, only the
      owner of <code>priv</code> can disseminate the labeled password
      (result) arbitrarily.
    </div>

    <div class="example">
      Suppose <code>https://university.edu</code> wished to isolate
      different parts of their site, for example, according to the
      users. The author can drop the privilege of a page
      <code>https://university.edu/~user1</code>:

      <pre><code lang-js>
        var uni = new <a interface>Label</a>("https://university.edu");
        // Create a new label that corresponds to user1's data on university.edu:
        var user1 = uni.or("cowl://user1"); // Here the cowl:// is an arbitrary <a>scheme</a>

        // Assume: COWL.privilege.asLabel().equals(uni);
        // Drop the current context privilege to a delegated privilege:
        COWL.privilege = COWL.privilege.delegate(user1);
      </code></pre>

      At this point, the context can only arbitrarily disseminate data
      that is labeled
      <code><a interface>Label</a>("https://university.edu").or("cowl://user1")</code>;
      it cannot disseminate data that is
      sensitive to the university and is thus labeled
      <code><a interface>Label</a>("https://university.edu")</code>;
      or another user's data (e.g.,
      <code><a interface>Label</a>("https://university.edu").or("cowl://user2")</code>).

      Of course, this requires the author to properly label user data
      (e.g., when sending it to the client).

      Note, sub-domains should be used where possible to ensure
      isolation. Nevertheless, COWL's labels can serve as another
      layer of defense.
    </div>

  </section>

  <section>
    <h3 id="context-labels">Labeled Contexts</h3>

    ISSUE: describe danger of using privileges implicitly; recommend
    using LabeledObjects everywhere.

    ISSUE: for discussion: should privileges be used explicitly?


    <pre class="idl">
      interface COWL {
        static attribute boolean enabled;

        [SetterThrows] static attribute Label confidentiality;
        [SetterThrows] static attribute Label integrity;

        [SetterThrows] static attribute Privilege privilege;
      };
    </pre>

    <h4>Attributes</h4>
    <dl dfn-for="COWL">
      <dt><dfn attribute title="COWL/enabled">enabled</dfn></dt>
      <dd>
        * On setting, the user agent MUST enable <a>confinement mode</a> for
        the current context.

        * On getting, the user agent MUST return <code>true</code> if
        the <a>confinement mode</a> was enabled for the current context;
        else, it MUST return <code>false</code>
      </dd>
      <dt><dfn attribute title="COWL/confidentiality">confidentiality</dfn></dt>
      <dd>
        * On getting, the user agent MUST return the <a>current
        confidentiality label</a>.

        * On setting, the user agent MUST use an algorithm equivalent
        to the following:

          1. Let <var>conf</var> be the set confidentiality label.
        
          2. Let <var>canWrite</var> be the result of invoking
          the <a>write check</a> algorithm with <var>conf</var>
          and the <a>current integrity label</a>.
          
          3. If <var>canWrite</var> is <code>false</code>, the user
          agent MUST throw a <a spec="HTML5">SecurityError</a>
          exception and terminate this algorithm.

          4. Else, the user agent MUST set the <a>current
          confidentiality label</a> to <var>conf</var>

      </dd>
      <dt><dfn attribute title="COWL/integrity">integrity</dfn></dt>
      <dd>
        * On getting, the user agent MUST return the <a>current
        integrity label</a>.

        * On setting, the user agent MUST use an algorithm equivalent
        to the following:

          1. Let <var>int</var> be the set integrity label.
        
          2. Let <var>canWrite</var> be the result of invoking the
          <a>write check</a> algorithm with the <a>current
          confidentiality label</a> and <var>conf</var>.
          
          3. If <var>canWrite</var> is <code>false</code>, the user
          agent MUST throw a <a spec="HTML5">SecurityError</a>
          exception and terminate this algorithm.

          4. Else, the user agent MUST set the <a>current
          integrity label</a> to <var>int</var>

      </dd>
      <dt><dfn attribute title="COWL/privilege">privilege</dfn></dt>
      <dd>
        * On getting, the user agent MUST return the <a>current
        privilege</a>.

        * On setting, the user agent MUST set the <a>current
        privilege</a> to the set privilege.


      </dd>
    </dl>
  </section>

  <section>
    <h3 id="object-labels">Labeled Objects Interface</h3>
    A <a interface>LabeledObject</a> MUST have an internal <dfn>protected
      object</dfn>, a confidentiality <a>label</a>, and an
    integrity <a>label</a>.

    <pre class="idl">
    dictionary CILabel {
      Label? confidentiality;
      Label? integrity;
    };

    [Constructor(object obj, CILabel labels)]
    interface LabeledObject {
      readonly attribute Label confidentiality;
      readonly attribute Label integrity;

      [GetterThrows] readonly attribute object protectedObject;

      [Throws] LabeledObject clone(CILabel newLabels);
    };
    </pre>
    <h4>Constructors</h4>
    <dl dfn-for="LabeledObject">
      <dt><dfn constructor>LabeledObject(obj, labels)</dfn></dt>
      <dd>

      When invoking the <a>LabeledObject()</a> constructor, the user
      agent MUST use an algorithm equivalent to the following:

      1. Let <var>obj clone</var> be the result of obtaining a
      <a>structured clone</a> of the <a argument
      for="LabeledObject/LabeledObject(obj, labels)">protectedObject</a> argument.

      2. Let <var>conf</var> be the <a dict-member
      for="CILabel">confidentiality</a> member of the <a argument
      for="LabeledObject/LabeledObject(obj, labels)">labels</a>
      argument, if it is set.  Otherwise, let <var>conf</var> be
      the <a>current confidentiality label</a>.

      3. Let <var>int</var> be the <a dict-member
      for="CILabel">integrity</a> member of the <a argument
      for="LabeledObject/LabeledObject(obj, labels)">labels</a>
      parameter, if it is set.  Otherwise, let <var>int</var> be the
      <a>current integrity label</a>.

      4. Let <var>canWrite</var> be the result of invoking the <a>write
      check</a> algorithm with the <var>conf</var> and <var>int</var> labels.

      5. If <var>canWrite</var> is <code>false</code>, the constructor
      MUST throw a <a spec="HTML5">SecurityError</a> exception
      and terminate this algorithm.

      6. Else, the constructor MUST return a new
      <a interface>LabeledObject</a>, with the <a>protected object</a>
      set to <var>obj clone</var>, the confidentiality label set to
      <var>conf</var>, and the integrity
      label set to <var>int</var>.
      </dd>
    </dl>

    <div class="note">
      Because COWL enforces labels at context boundaries, there is
      usually no reason to label an object and then use the labeled
      object within the same context.  <a interface>LabeledObject</a>s
      are mainly useful for sending sensitive data to an untrusted
      context, e.g., via cross-document messaging, as a way to ensure
      that the data's confidentiality and integrity (as specified by
      the labels) are respected by the untrusted context. Hence, the
      <a>LabeledObject()</a> constructor only accepts objects that can
      be <a>structurally cloned</a>.
    </div>

    <h4>Attributes</h4>
    <dl dfn-for="LabeledObject">
      <dt><dfn attribute title="LabeledObject/confidentiality">confidentiality</dfn></dt>
      <dd>
        On getting, the user agent MUST return the <a
        interface>LabeledObject</a>'s confidentiality label.
      </dd>
      <dt><dfn attribute title="LabeledObject/integrity">integrity</dfn></dt>
      <dd>
        On getting, the user agent MUST return the <a
        interface>LabeledObject</a>'s integrity label.
      </dd>
      <dt><dfn attribute title="LabeledObject/protectedObject">protectedObject</dfn></dt>
      <dd>
        On getting, the user agent MUST use an algorithm equivalent to
        the following:

        1. Invoke the <a>context tainting</a> algorithm with the <a
        interface>LabeledObject</a>'s confidentiality and integrity labels.
        
        2. If the <a>context tainting</a> algorithm raises an
        exception, rethrow the exception and terminate this algorithm.

        3. Return the <a interface>LabeledObject</a>'s <a>protected
        object</a>.
      </dd>
    </dl>

    <div class="note">
      Note: the labels of a <a interface>LabeledObject</a> are
      essentially public: code can always inspect labels. However, to
      inspect the internal, <a>protected object</a> the current
      context must be tainted according to the object's labels. This
      ensures two things:

      * The context can't violate the confidentiality of the data (as
      specified by the confidentiality label) by communicating
      arbitrarily once it reads data labeled as such.

      * The context can't violate the integrity of entities more
      trustworthy than the data. (The trustworthiness of the data is
      specified by the integrity label.) In particular, once the
      context reads the data and gets tainted, the rest of the
      computation is restricted to writing to entities that are at
      most as trustworthy as the data, for the read data may have
      influenced the computation.
    </div>

    <h4>Methods</h4>

    ISSUE: describe <code>clone</code>



  </section>

</section>

<!-- Big Text: algorithms -->
<section>
  <h2 id="algorithms">Algorithms</h2>
  <section>
    <h3 id="reduce-to-normal-form">Label Normal Form Reduction</h3>
    The <dfn>label normal form reduction</dfn> algorithm takes a
    <var>label</var> argument and produces a <a>Label</a> value
    according to the following steps:

    ISSUE: describe the reduction algorithm

  </section>
  <section>
    <h3 id="subsumes-check">Label Subsumption</h3>
    The <dfn>label subsumption</dfn> algorithm takes a two labels
    <var>A</var> and <var>B</var> and produces a boolean according to
    these steps:

    ISSUE: describe the subsumes algorithm

  </section>
  <section>
    <h3 id="label-reduce">Label Downgrade</h3>
    The <dfn>label downgrade</dfn> algorithm takes a label,
    <var>label</var> and a privilege<var>priv</var>, and returns
    the least restricting label according to the following steps:

    ISSUE: describe downgrade

  </section>
  <section>
    <h3 id="taint-context">Context Tainting</h3>
    The <dfn>context tainting</dfn> algorithm takes a two labels,
    <var>confidentiality</var> and <var>integrity</var>, and updates
    the <a>context labels</a> to allow for reading data labeled with
    these labels.

    ISSUE: describe taint

  </section>
  <section>
    <h3 id="write-check">Write Check</h3>
    The <dfn>write check</dfn> algorithm takes a two labels,
    <var>confidentiality</var> and <var>integrity</var>, and returns
    <code>true</code> if the current context is allowed to write to
    (or create) an entity labeled as such; otherwise, it returns
    <code>false</code>.

    ISSUE: describe write check

  </section>
</section>
